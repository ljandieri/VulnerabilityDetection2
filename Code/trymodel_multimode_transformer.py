import myutils
from datetime import datetime
import sys
import numpy as np
import os
import pickle
from keras.models import load_model
from gensim.models import Word2Vec, KeyedVectors
from keras.preprocessing import sequence
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
import tensorflow as tf
import numpy
import transformerBlockModel
from transformerBlockModel import TokenAndPositionEmbedding
from transformerBlockModel import TransformerBlock

import keras

def printAndLog(logString,filename):
  print(logString)
  filename.write(logString + '\n')

#trying to activate GPU
tf.config.experimental.list_physical_devices('GPU')

#default mode / type of vulnerability
# command_injection / open_redirect / path_disclosure / remote_code_execution / sql / xsrf / xss
mode = "path_disclosure"

#get the vulnerability from the command line argument
if (len(sys.argv) > 1):
  mode = sys.argv[1]

#model = load_model('model/LSTM_model_'+mode+'.h5',custom_objects={'f1_loss': myutils.f1_loss, 'f1':myutils.f1})
custom_objects = {"TokenAndPositionEmbedding": TokenAndPositionEmbedding, "TransformerBlock": TransformerBlock,'f1_loss': myutils.f1_loss, 'f1':myutils.f1}

#modelName = None
modelName = 'Transformer_model_filtertest_step20_length200_edim32_numhead1_ffsz32_droput0.05_outsz1_opt_RMSprop_btsz1024_eps50_tokvocsize30000_mxl100.h5'
modelPath = 'transformers/multimode/models/' + modelName
#modelPath = 'transformers/transformerModels/' + mode + '/Transformer_model_edim32_numhead2_ffsz32_droput0.1_outsz1_opt_adam_btsz1024_eps100_tokvocsize30000_mxl50_xsrf.h5'
model = tf.keras.models.load_model(modelPath, custom_objects=custom_objects)

step = 5
window_length = 500
modes = {
    'xss':0,
    'remote_code_execution':0
}

for mode in modes.keys():
    with open('separatedBlocks/' + mode + f'_processed_step{step}_length{window_length}_test', 'rb') as fp:
      FinaltestX = pickle.load(fp)
    with open('separatedBlocks/' + mode + f'_processed_step{step}_length{window_length}_test_labels', 'rb') as fp:
      FinaltestY = pickle.load(fp)

now = datetime.now() # current date and time
nowformat = now.strftime("%H:%M")

#Prepare the data for the LSTM model
tokenizer = None
tokenizerPath = 'transformers/multimode/models/keras_tokenizer.pickle'
if os.path.isfile(tokenizerPath):
  with open(tokenizerPath,'rb') as f:
      tokenizer = pickle.load(f)
else:
  print('tokenizer not found')
  exit(1)

test_texts_to_int = tokenizer.texts_to_sequences(FinaltestX)
X_finaltest = keras.preprocessing.sequence.pad_sequences(test_texts_to_int,
                                                              maxlen=100,
                                                              truncating='pre',
                                                              padding='post')
y_finaltest = numpy.array(FinaltestY)

for i in range(len(y_finaltest)):
  y_finaltest[i] = 1 - y_finaltest[i]

now = datetime.now() # current date and time
nowformat = now.strftime("%H:%M")
resPath = 'transformers/multimode/'
f= open(resPath + mode + '_res.txt','w')
printAndLog(str(len(X_finaltest)) + " samples in the final test set.",f)
  
  
csum = 0
for y in y_finaltest:
  csum = csum+y

printAndLog("percentage of vulnerable samples: "  + str(int((csum / len(X_finaltest)) * 10000)/100) + "%",f)
printAndLog("absolute amount of vulnerable samples in test set: " + str(csum),f)



yhat_classes = (model.predict(X_finaltest) > 0.5).astype("int32")
#yhat_classes = model.predict(X_finaltest,verbose=0)
#yhat_classes = np.argmax(model.predict(X_finaltest,verbose=0))
#yhat_classes = model.predict_classes(X_finaltest, verbose=0)

accuracy = accuracy_score(y_finaltest, yhat_classes)
precision = precision_score(y_finaltest, yhat_classes)
recall = recall_score(y_finaltest, yhat_classes)
F1Score = f1_score(y_finaltest, yhat_classes)


#f= open(mode + '_stats.txt','w')
printAndLog("Accuracy: " + str(accuracy),f)
#f.write("Accuracy: " + str(accuracy))
printAndLog("Precision: " + str(precision), f)
#f.write("Precision: " + str(precision))
printAndLog("Recall: " + str(recall), f)
#f.write("Recall: " + str(recall))
printAndLog('F1 score: %f' % F1Score, f)
#f.write('F1 score: %F' % F1Score)
printAndLog("\n",f)
f.close()




